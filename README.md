-Для чего webgl
-рассказать определение терминов (шейдер, квад)
-обобщить про cpu / gpu (на примере ноута)
-попроще про пайплайн, объяснить все термины
-покороче про 2д

### Слайд 2
Для начала стоит рассказать, что же такое WebGL. WebGL - это графическое API, которое позволяет отправлять команды на видеокарту из JavaScript’a . Разрабатывается компанией хронус групп. Контрибьютят в WebGL такие компании, как apple, google, ea games, intel, facebook и другие.
Библиотека WebGL в основном используется для осуществления 3D рендеринга, позволяет создавать в браузере удивительные 3D игры, сцены и эффекты. Пока большинство из них just for fun, но некоторые могут быть уже сегодня использоваться на живых сайтах. Сейчас WebGL также можно встретить на сайтах автомобилей вроде порше и других.

### Слайд 3
WebGL программы состоят из программ, написанных на JavaScript, и специального кода шейдеров, который выполняется на видеокарте. Шейдеры написаны на C-подобном языке GLSL. Зачем нам нужно отправлять что-то на видеокарту? Есть ряд задач, которые видеокарта может выполнять гораздо быстрее процессора, так как количество задач, которые могут параллельно выполняться на видеокарте гораздо большее, чем у CPU. 
Для примера можно рассмотреть мой рабочий ноутбук, на котором я разрабатывала код. Процессор Core i7, 2,7гГц, у которого 4 ядра, видеокарта Radeon Pro 450
640 ядер. На CPU может параллельно выполняться 4 потока, а на видеокарте 640 потоков, Но работа, которую могут выполнять ядра видеокарты ограничена по сравнению с центральным процессором, так как архитектура ядер проще, чем у CPU, так как видеокарта заточена на параллельное выполнение несвязанных между собой задач. Например, расчет цвета для каждого пикселя изображения. 


### Слайд 4
Давайте теперь поподробнее рассмотрим, как мы рисуем что-либо с помощью WebGL. Например, мы хотим нарисовать некий трехмерный объект. Для этого нам необходимо описание этого объекта - некоторая геометрия, состоящая из треугольников и материалов, которые описывают, как эти треугольники нужно раскрасить. Модель можно подготовить в каком-либо 3d пакете или создать процедурно кодом.
После того, как мы загрузим модель, чтобы ее отрисовать нам необходимо преобразовать позиции всех треугольников из координатного пространства модели в координатное пространство камеры, после этого сделать проекцию результирующей модели на экран, а затем спроецированные треугольники разбиваются на фрагменты в растеризаторе, а после этого определяется цвет для каждого фрагмента во фрагментном шейдере.

### Слайд 5
Работа с видеокартой происходит по принципу клиент-сервера, в данном случае js - это клиент, а видеокарта - это сервер. Мы отправляем запросы с клиента на сервер через интерфейс WebGL и на сервере эти запросы выполняются. С помощью функции gl.bufferData(...) - мы переносим данные из javascript’a на видеркарту, например данные вершин (вершинный буфер). gl.drawElements(...) используем для того, чтобы сказать видеокарте, что нам нужно отрисовать какое-то количество примитивов. То есть это основная функция отрисовки
* gl.bufferData(...) 
* gl.drawElements(...) 
Описание геометрии может выглядеть вот так: <code>

### Слайд 6
Работа видеокарты построена по принципу конвейера и разбита на несколько этапов. Эти этапы можно условно разделить на 2 группы - фиксированные и программируемые.
Фиксированные - это этапы, которые не программируются, им можно задавать только входные параметры. Они фиксированы на железе. Алгоритм работы поменять невозможно.
Программируемые - это те, которые описываются шейдерными программами.
1й этап - фиксированный этап - Input Assembler (мы задаем вершинный буфер и индекс буфер, по индекс буферу мы определяем вершину, которую мы будем обрабатывать в следующем этапе) 
2й этап - программируемый - Вершинный шейдер (Vertex shader) - берет вершину и делает какие-то преобразования. Обычно это преобразования из координатного пространства модели в координатное пространство камеры путем перемножения вершин модели на перемноженные между собой матрицы. В данном случае - это 4х мерные матрицы (у которых 4 вектора - x,y,z,w) x,y,z - трехмерный координатный базис, а 4й компонент w - отвечает за смещение. Матрицы, которые мы перемножаем - первая это матрица перевода вершин из пространства модели в мировое пространство. Вторая матрица - это матрица перевода из мирового пространства в пространство камеры. А третья - из пространства камеры в пространство отсечения, то есть мы применяем матрицу перспективной проекции у этой матрицы 4й компонент w - отвечает за перспективное деление.
3й этап - фиксированный - Сборка примитивов (Primitive Assembly) - собирает из вершин примитивы - чаще всего это треугольники (WebGL - поддерживает три типа примитивов - точки, линии и треугольники) 
4й этап - растеризация (Rasterizer) - это когда на вход передан некий примитив из предыдущего этапа. Видеокарта его проецирует на экран и определяет, какие пиксели на экране входя в этот примитив (треугольник) Эти пиксели называются фрагментами в теринах WebGL. Также этим фрагментам присваиваются интерполированные значения из вершинного шейдера. В WebGL эти интерполируемые значения  называется varying.
5й этап - Фрагментный шейдер (Fragment Shader) - он работает с данными, полученными из предыдущего этапа, то есть для каждого фрагмента, полученного из Rasterizer мы выполняем один фрагментый shader. На выходе фрагментый шейдер нам дает цвет итогового фрагмента.
6й этап - Output Merger - блендинг - он делает тест - сравнивает альфу текущего фрагмента с тем, что уже записано в фрейм буфер и по формуле, которую мы можем задавать из JavaScript’a, он складывает эти значения и делает запись итогового цвета в фреймбуфер. Фрейм буфер - это текстура, в которую можно писать из шейдера.
Давайте поподробнее остановимся на этапах - вершинный шейдер, растеризация и фрагментый шейдер.

### Слайд 7
1й программируемый этап- это вершинный шейдер. На этом этапе мы получаем данные, которые описывают вершину из вершинного буфера (ARRAY_BUFFER) через атрибуты и как правило в этих данных есть позиция, нормаль, текстурные координаты и прочее. В коде программы вершинного шейдера мы производим некие преобразования над этими данными, например, для позиций мы конвертируем их в нормализованное координатное пространство (картинка из 13 слайда) На выходе вершинный шейдер должен возвращать значение gl_Position и через интерполяторы можно передавать и другие данные на следующий этап. В WebGL интерполяторы это varying переменные.

### Слайд 8
Следующий этап - это растеризация - это непрограмируемый этап. В этом этапе видеокарта определяет, какие пиксели в итоговом Frame buffere перекрываются рисуемым примитивом (треугольником)
+ картинка 14 слайда

### Слайд 9
Фрагментный шейдер (Fragment Shader) - он работает с данными, полученными из предыдущего этапа, то есть для каждого фрагмента, полученного из Rasterizer мы выполняем один фрагментый shader. На выходе фрагментый шейдер нам дает цвет итогового фрагмента.
Также хотелось бы отметить, что на обоих этапах, и на этапе вершинного и фрагментного шейдеров, что мы можем поспользовать константы, установленные из javascript, в терминах WebGL - это uniforms 

### Слайд 10
Первое с чего можно начать изучение WebGL - это написание фильтров для преобразования изображений.
Чтобы это сделать необходимо на html страницу добавить canvas, из этого canvasa в javascripte получить webgl контекст, если браузер его поддерживает, а дальше можно начать рисование с этим контекстом. Чтобы нарисовать картинку с наложением каких-либо фильтров необходимо нарисовать на экране 2 треугольника, которые образуют собой фигуру, называемую квад, квад - это прямоугольный примитив. Для того, чтобы нарисовать этот квад необходимо иметь скомпилированную шейдерную программу, которая состоит из слинкованных вершинного и фрагментного шейдера. Линковка в данном случае означает, что мы соотнесли входные и выходные данные между этими шедеврами.  
В вершинном шейдере на вход получаем позиции и текстурные координаты квада, мы передаем их через varying во фрагменты шейдер
Во фрагментом шейдере с помощью текстурных координат мы читаем данные изображения и в каждом фрагменте возвращаем цвет.

Например, для эффекта blur мы во фрагментном шейдере берем несколько текселей (1 единица (пиксель) в текстуре)вокруг текущего фрагмента и считаем взвешенную сумму этих текселей, а для bw - берем среднеарифметическое rgb-каналов в текущем текселе.
+ гифка

// Написала вершинный шейдер, он один для всех эффектов. В нем мы преобразуем входные координаты квада матрицы трансформации для того, чтобы иметь возможность вращать и увеличивать/уменьшать изображение. 
Для каждого эффекта мы создаем свой фрагментный шейдер. Этот шейдер на вход получает изображение, и на выходе его как-то преобразует. 
Например, для эффекта blur мы во фрагментном шейдере берем несколько текселей (1 единица (пиксель) в текстуре)вокруг текущего фрагмента и считаем взвешенную сумму этих текселей, а для bw - берем среднеарифметическое rgb-каналов в текущем текселе.
Так как накладывается несколько эффектов друг поверх друга, то их необходимо накапливать в некотором промежуточном фрейм буффере и только в конце содержимое этого буфера копируется на экран, предварительно отразив его по вертикали (оси y) это связано с особенностью представления фрейм буферов в WebGL.//

### Слайд 11
После того, как мы разобрались, с тем, как работает графический pipeline WebGL на примере 2d интересно было бы перейти к 3d.  И я решила попробовать создать процедурно планету. 
+ картинка планеты

### Слайд 12
+ картинка проекций
Что нам нужно для этого? 
Нам нужен некий 3d меш, меш - это набор треугольников, разместить его на сцене в нуле координат, нацелить на него камеру, преобразовать вершины этого меша в координатное пространство камеры и применить перспективную проекцию.
Можно остановиться немного подробнее на перспективной проекции, нужно для начала понять, что такое вообще проекция. Проекция - это представление 3d модели на плоскости, например, на экране. Обычно используется 2 типа проекции в компьютерной графике - ортогональная и перспективная проекция. Разница в том, что в ортогональной проекции линии проецирования переносятся перпендикулярно плоскости проекции, а в перспективной луч проекции идет от проецируемой точки в позицию камеры, то есть так видит человеческий глаз. Основная особенность перспективной проекции, что объекты на удалении от камеры становятся меньше.

### Слайд 13
+ картинки сфер
Дальше стоит поговорить про 3d меш. В основе планеты лежит сфера. Сгенерировать триангулированную сферу мы можем тремя способами - icosphere (икосфера), uv-sphere(ювисфера) и cube-sphere (кубическая сфера). У икосферы есть проблемы, нужно большее количество треугольников, чтобы получить сглаженную поверхность, сложнее рассчитывать текстурные коррдинаты и сама процедура генерации этой сферы нетривиальная.
Что касается uv-сферы, она довольно популярна, так как она достаточно проста в реализации, но у нее есть значительная проблема, которая заключается в том, что на полюсах площадь треугольников мала, из-за этого там появляются геометрические артифакты. Поэтому когда делают uv-сферу, то на полюсах делают отдельные меши, то есть сфера получается из 3х фигур, средняя часть и крышки. Но я решила остановиться на третьем варианте - это сфера полученная из куба. Для этого мы генерируем куб, каждая сторона которого представляет равномерную сетку. И каждую вершину этой сетки мы вытягиваем по нормали. Нормаль мы получаем вычитая из позиции вершины на сетки позицию центра сферы и полученный вектор мы нормализуем. Хотелось бы отметить, что при отрисовки сферы необходимо использовать Back Face Cooling и тест глубины (Debth test)   Back Face Cooling - нужен для того, чтобы треугольники, которые отвернуты от нас не рисовались, так как они находятся на обратной стороне сферы, а тест глубины нужен для того, чтобы треугольники рисовались в правильном порядке, чтобы впереди стоящий треугольник не перекрывался позади стоящим.

### Слайд 14
+ картинку ноиза
После того, как наша сфера готова необходимо сгенерировать землю, горы, воду и облака. Для этого мы используем карту высот, которая генерируется процедурно в шейдере и по этой карте высот смещаем вершины в вершинном шейдере и окрашиваем в фрагментном. Например, там где высота ниже уровня воды - рисуем синий цвет, и так далее. Для генерации высот используется три октавы симплекс ноиза. Симплекс ноиз (blue noise) - это непрерывная функция шума, она часто применяется в компьютерной графике, раньше для таких вещей использовалась функция Перлин noise, но она достаточно громоздкая и сложнее, а симплекс ноиз оптимальнее. 3 окатавы - взяли три сигнала разной частоты и сложили их в один.

### Слайд 15
гифка вращения планеты с облаками
После этого планета по факту готова. Как бонус я добавила облака. Они также рисуются сферой с чуть большим радиусом, чем планета. Облака используют ту же функцию шума, единственное, что как цвет они используют белый, а шум определяет прозрачность облаков в точке. Для того чтобы облака с прозрачностью рисовались поверх планеты в javascripte нужно включить альфа блендинг
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
Первый параметр - это то, на что мы умножаем source - это то, что мы пишем из шейдера, то есть мы умножаем rgb на альфу, а в дестинэйшене, это то, rgb, который в фреймбуфере мы умножаем на (1 -альфу)
blendResult = shaderOutput.rgb * shaderOutput.a + frameBuffer.rgb * (1 - shaderOutput.a);

Еще я добавила анимацию вращения облаков вокруг оси y.

### Слайд 16
+ поискать картинку освещения + формулу фонга
Для того чтобы сделать 3д модель объёмной , ее необходимо осветить. Для освещения я использую самую простую модель, собственно модель фонга. Не буду вдаваться в подробности, чтобы не занудничать, в интернете об этом очень много информации.

### Слайд 17
Сглаживание

После того, как мы нарисовали планету, мы можем заменить некоторые артифакты на границе геометрии, это так называемый алязинг, он вызван тем, что итоговое изображение состоит из пикселей, размер которых виден глазом, и при отрисовке треугольников растеризатор генерирует паттерн похожий на лесенки. Чтобы решить эту проблему я использовала довольно распространенный алгоритм сглаживания FXAA - fast approximate anti-aliasing. В двух словах - он берет итоговое изображение и проходит попиксельно по нему и пытается понять находимся ли мы на границе геометрии или нет, и если мы на границе, то мы используем не один сэмпл, а несколько, мы их усредняем и получаем более сглаженные края. Определение границ происходит - то есть RGB переводит в яркость, сравниваем с соседними если есть разница, то эта граница, надо проверить горизонтальная или вертикальная 

### Слайд 18
Выводы
Заниматься WebGL довольно интересно.
Я писала на чистом WebGL,но есть библиотеки, которые сильно упрощают задачу, вроде three.js, но для этой конкретной задачи эта библиотека слишком громоздкая. Вот есть статья у Ситника, как он пытался ускорить загрузку страницы с three.js, путем загрузки этого контекста в вебворкер.




==================================================================




Код для программируемых этапов - вершинного и фрагментного буферов пишется на языке GLSL - это императивный процедурный строготипизированный язык с Си-подобным синтаксисом. Он имеет ряд встроенных функций для различных математических операций. И интересная особенность - у него встроен компонент-свизлинг на векторных типах (Swizzle GLSL)- это значит, что переменная состоит из n-количества компонент и есть возможность обратиться к каждой компоненте переменной.
	vec2 someVec;
	vec4 otherVec = someVec.xyxx;
	vec3 thirdVec = otherVec.zyy;

Чтобы выполнить что-то на GPU нам необходимо иметь скомпилированную программу. Это слинкованные вместе скомпилированные вершинный и фрагментый шейдеры. Линковать их необходимо для того, чтобы выходные параметры вершинного шейдера соответствовали входным параметрам фрагментарного шейдера. 
Имея скомпилированную программу, мы можем вызвать команду отрисовки - в WebGL это или DrawElements или DrawArrays. DrawElements использует index- буффер, а DrawArrays не использует index-буффер и считает, что в вершинном буффере каждые три вершины образуют треугольник (то есть вершины могут повторяться), тогда как при использовании index-буффера мы можем ссылаться на одну и ту же вершину по индексу. Поэтому для улучшения производительности чаще используется DrawElements.
Для того, чтобы что-то отобразить необходимо забиндить вершинный буффер, а в случае DrawElements и индексный буфер тоже.
Вершинный буфер - это массив, в котором хранится информация о вершинах, например, позиция вершины (координаты), ее цвет, текстурные координаты, нормаль, тангенс и прочее. Данные из буфера доступны в вершинном шейдере через атрибуты.
Также в шейдерную программу можно передавать константы через uniform переменные - это глобальные переменные, которые устанавливаются перед выполнением программы шейдера. Также у нас есть Varying-переменные позволяют передавать данные из вершинного шейдера фрагментному шейдеру, они интерполируются. 
Еще важная особенность, что в шейдера мы можем читать текстуры - это массивы данных, к которым есть доступ в программе шейдера. Чаще всего в текстуру помещается картинка, но текстура - это просто набор данных и вы можете запросто поместить в неё что-то отличное от набора цветов.

Я взяла изображение и тут-то столкнулась с такой проблемой, что WebGL просто блокирует все изображения, которые приходят с других доменов, потому что в изображениях может содержаться какая-то приватная информация. То есть используя WebGL нет возможности прочитать изображение с другого домена, не запросив разрешение через CORS, поэтому при запросе изображения у сервера мы пишем img.crossOrigin = ‘’; так как по-умолчанию при запросе изображения Img.crossOrigin = undefined, что значит что разрешение не запрашивается. 
Я загрузила изображение через img src и накладывала на него различные фильтры (blur, b/w, анимацию и вращение).
С точки зрения WebGL мы рисуем Quad по размеру canvas - он состоит из 2х треугольников. 






