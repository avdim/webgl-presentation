### Слайд 4
Почему я решила рассказать про WebGL?
* WebGL - это отличный способ развлечь себя решением нестандартных для фронтендера задач в знакомой среде
* Возможность узнать что-то новое про компьютерную графику

### Слайд 4   
Что я расскажу?
* Что такое WebGL?
* Как WebGL работает?
* Как рисовать 2d на WebGL
* Как создать 3d планету на WebGL без использования библиотек и фреймворков

### Слайд 4
Для начала стоит рассказать, что же такое WebGL. WebGL - это графическое API, которое позволяет отправлять команды на видеокарту из JavaScript’a.

### Слайд 5
Разрабатывается компанией хронус групп. Контрибьютят в WebGL такие компании, как apple,google, ea games, intel, facebook и другие.

### Слайд 6
Библиотека WebGL в основном используется для осуществления 3D рендеринга, позволяет создавать в браузере удивительные 3D игры, сцены и эффекты.
* Используется для работы работы с растровыми изображениями в браузере, например, наложение фильтров.
* Для создания интерактивных анимаций на сайтах
* Интерактивная презентация машин и интерьеров
* Для проигрывателей музыки в браузере
* В Германии проходит 3D web fest, где люди могут загружать свои изображения и делиться опытом
* И конечно же игры. На сегоднящний день все современные игровые движки такие, как unreal engine 4, unity поддерживают экспорт в WebGL

### Слайд 14
WebGL программы состоят из программ, написанных на JavaScript, и специального кода шейдеров, который выполняется на видеокарте. Шейдеры написаны на C-подобном языке GLSL. 

### Слайд 15
Зачем нам нужна видеокарта? В отличии от центрального процессора видеокарта имеет другую архитектуру, которая предназначена для выполнения несвязанных между собой задач, например, таких как расчет цвета пикселя, что позволяет иметь на видеокарте огромное количество ядер, следовательно выполнять значительно больше задач одновременно, чем на центральном процессоре.
Для примера на моем ноутбука, на котором я разрабатывала код - процессор Core i7, у которого 4 ядра и видеокарта Radeon Pro 450, у которой 640 ядер. 

### Слайд 16
Работа с видеокартой происходит по принципу клиент-сервера, в данном случае JavaScript - это клиент, а видеокарта - это сервер. Мы отправляем запросы с клиента на сервер через интерфейс WebGL, и на сервере эти запросы выполняются. 

### Слайд 17
Давайте теперь поподробнее рассмотрим, как видеокарта рисует что-либо с помощью WebGL.

### Слайд 18
Например, мы хотим нарисовать некий трехмерный объект. Для этого нам необходимо описание этого объекта - некая геометрия, состоящая из треугольников и материалов, которые описывают, как эти треугольники нужно раскрасить. Модель можно подготовить в каком-либо 3d пакете или создать процедурно кодом.

### Слайд 19
После того, как мы загрузим модель, чтобы ее отрисовать нам необходимо преобразовать позиции всех треугольников из координатного пространства модели в координатное пространство камеры, после этого сделать проекцию результирующей модели на экран, а затем спроецированные треугольники разбиваются на фрагменты в растеризаторе, а после этого определяется цвет для каждого фрагмента во фрагментном шейдере.

### Слайд 20
Работа видеокарты построена по принципу конвейера и разбита на несколько этапов. Эти этапы можно условно разделить на 2 группы - фиксированные и программируемые.
Фиксированные - это этапы, которые не программируются, им можно задавать только входные параметры. Они фиксированы на железе. Алгоритм работы у них поменять невозможно.
Программируемые - это те, которые описываются шейдерными программами.

### Слайд 21
1й этап - Input Assembler - это фиксированный этап (мы задаем вершинный буфер и индекс буфер, по индекс буферу мы определяем вершину, которую мы будем обрабатывать в следующем этапе) 
С помощью функции gl.bufferData(...) - мы переносим данные из javascript’a на видеркарту, например, данные вершин. 

### Слайд 22
2й этап- Вершинный шейдер - это программируемый этап

### Слайд 23
На этом этапе мы получаем данные, которые описывают вершину из вершинного буфера (ARRAY_BUFFER) через атрибуты и как правило в этих данных есть позиция, нормаль, текстурные координаты и прочее. 

### Слайд 24
Далее делаются некие преобразования над этими данными. Обычно это преобразования из координатного пространства модели в пространство отсечения путем перемножения вершин модели на перемноженные между собой матрицы. 
В данном случае - это 4х мерные матрицы (у которых 4 компонента - x,y,z,w) x,y,z - трехмерный координатный базис, а 4й компонент w - отвечает за смещение. Матрицы, которые мы перемножаем - первая из них - это матрица трансформации вершин из пространства модели в мировое пространство. Вторая матрица - это матрица трансформации из мирового пространства в пространство камеры. 

### Слайд 25
А третья - матрица трансформации из пространства камеры в пространство отсечения, то есть мы применяем матрицу перспективной проекции у этой матрицы 4й компонент w - отвечает за перспективное деление.

### Слайд 
Можно остановиться немного подробнее на перспективной проекции, но для начала нужно понять, что такое вообще проекция. Проекция - это представление 3d модели на плоскости, например, на экране. Обычно используется 2 типа проекции в компьютерной графике - ортогональная и перспективная проекция. Разница в том, что в ортогональной проекции линии проецирования переносятся перпендикулярно плоскости проекции, а в перспективной луч проекции идет от проецируемой точки в позицию камеры, то есть так видит человеческий глаз. Основная особенность перспективной проекции, что объекты на удалении от камеры становятся меньше.

### Слайд 26
На выходе вершинный шейдер должен возвращать значение gl_Position и через интерполируемые значения можно передавать данные на следующий этап.
// В WebGL интерполируемые значения это varying переменные. 

### Слайд 27
3й этап - фиксированный - Сборка примитивов (Primitive Assembly)

### Слайд 28
Собирает из вершин примитивы - чаще всего это треугольники (WebGL - поддерживает три типа примитивов - точки, линии и треугольники) 

### Слайд 29
4й этап - Растеризация - фиксированный этап

### Слайд 30
На вход передан некий примитив(треугольник) из предыдущего этапа. Видеокарта его проецирует на экран и определяет, какие пиксели на экране входя в этот треугольник. Эти пиксели в терминах WebGL называются фрагментами. Также этим фрагментам присваиваются интерполированные значения из вершинного шейдера (в терминах GLSL - это varying).

### Слайд 31
5й этап - Фрагментный шейдер - программируемый этап

### Слайд 32
Фрагментный шейдер работает с данными, полученными из предыдущего этапа, то есть для каждого фрагмента, полученного из Rasterizer мы выполняем один фрагментый shader. На выходе фрагментый шейдер нам дает цвет итогового фрагмента.

<!-- ### Слайд 16
Также хотелось бы отметить, что на обоих этапах, и на этапе вершинного и фрагментного шейдеров, мы можем поспользовать константы, установленные из javascript, в терминах WebGL - это uniform переменные. -->

### Слайд 33
6й этап - тест и блендинг - он делает тест - сравнивает альфу текущего фрагмента с тем, что уже записано в фрейм буфер и по формуле, которую мы можем задавать из JavaScript’a, он складывает эти значения и делает запись итогового цвета в фреймбуфер. Фрейм буфер - это текстура, в которую можно писать из шейдера.

### Слайд 34
И так, подводим итог, что у нас есть:
* array buffer с данными о вершинах,
* в вершинном шейдере мы делаем преобразования над вершинами
* дальше - сборка примитивов (треугольников)
* в растеризаторе - определяем, какие пиксели(фрагменты) попадают в треугольники
* и во фрагментном шейдере расскрашиваем эти фрагменты

### Слайд 35
Первое с чего можно начать изучение WebGL - это написание фильтров для преобразования изображений.
Чтобы это сделать необходимо на html страницу добавить тег canvas, из этого canvasa в javascripte получить webgl контекст, если браузер его поддерживает, то дальше можно начать рисование с этим контекстом.

### Слайд 36
Чтобы нарисовать картинку с наложением каких-либо фильтров необходимо нарисовать на экране 2 треугольника, которые образуют собой фигуру, называемую квад. 
Для того, чтобы нарисовать этот квад необходимо иметь скомпилированную шейдерную программу, которая состоит из слинкованных вершинного и фрагментного шейдера. Линковка в данном случае означает, что мы соотнесли входные и выходные данные между этими шейдерами.
Я добавила эффекты blur, black and white и анимацию.
Все эти эффекты имеют общий вершинный шейдер.
Но для каждого эффекта необходимо создать свой фрагментный шейдер.
Во фрагментом шейдере с помощью текстурных координат мы читаем данные изображения и в каждом фрагменте возвращаем цвет.

//
В нем мы преобразуем входные координаты квада с помощью матрицы трансформации для того, чтобы иметь возможность вращать и увеличивать/уменьшать изображение. 
В вершинном шейдере на вход получаем позиции и текстурные координаты квада, мы передаем их через varying переменные во фрагментый шейдер.

Например, для эффекта blur во фрагментном шейдере берем несколько текселей (тексель - это 1 единица (пиксель) в текстуре)вокруг текущего фрагмента и считаем взвешенную сумму этих текселей, а для bw - берем среднеарифметическое rgb-каналов в текущем текселе.
Так как накладывается несколько эффектов друг поверх друга, то их необходимо накапливать в некотором промежуточном фрейм буффере и только в конце содержимое этого буфера копируется на экран, предварительно отразив его по вертикали (оси y) это связано с особенностью представления фрейм буферов в WebGL.
//

### Слайд 37
После того, как мы разобрались, с тем, как работает графический pipeline WebGL на примере 2d интересно было бы перейти к 3d.  И я решила попробовать создать процедурно планету. 

### Слайд 38
Что нам нужно для этого? 
Нам нужен некий 3d меш, меш - это набор треугольников, разместить меш на сцене в нуле координат, нацелить на него камеру, преобразовать вершины этого меша в координатное пространство камеры и применить перспективную проекцию.

### Слайд 39
Дальше стоит поговорить про 3d меш. В основе планеты лежит сфера. Сгенерировать триангулированную сферу мы можем четырьмя способами - icosphere, uv-sphere cube-sphere и normalised cube-sphere. 

### Слайд 40
uv-сфера довольно популярна, так как она достаточно проста в реализации, состоит из меридианов и параллелей, но у нее есть значительная проблема, которая заключается в том, что на полюсах площадь треугольников мала, из-за этого там появляются геометрические артифакты. Поэтому когда делают uv-сферу, то на полюсах делают отдельные меши, то есть сфера получается из 3х фигур, средняя часть и крышки. 

### Слайд 41
Икосферы - ее проблемы в том, что нужно большее количество треугольников, чтобы получить сглаженную поверхность, сложнее рассчитывать текстурные коррдинаты и сама процедура генерации этой сферы нетривиальная.

### Слайд 42
Я же решила остановиться на варианте - normalized cube сфера. Для этого мы генерируем куб, каждая сторона которого представляет равномерную сетку. И каждую вершину этой сетки мы вытягиваем по нормали. Нормаль мы получаем вычитая из позиции вершины на сетки позицию центра сферы и полученный вектор мы нормализуем. 

//
Хотелось бы отметить, что при отрисовке сферы необходимо использовать Back Face Cooling и тест глубины (Debth test). Back Face Cooling - нужен для того, чтобы треугольники, которые отвернуты от нас не рисовались, так как они находятся на обратной стороне сферы, а тест глубины нужен для того, чтобы треугольники рисовались в правильном порядке, чтобы впереди стоящий треугольник не перекрывался позади стоящим.
//

### Слайд
Нормаль - это единичный вектор, перпендикулярный поверхности в каждой данной её точке

### Слайд 43
После того, как наша сфера готова необходимо сгенерировать землю, горы, воду и облака. Для этого я использовала карту высот, которая генерируется процедурно в шейдере и по этой карте высот смещаются вершины в вершинном шейдере и окрашиваются в фрагментном. Например, там где высота ниже уровня воды - рисуется синий цвет, а где горы - коричневый и так далее. 

### Слайд 44
Распространенным способом создания 2D-карт является использование непрерывная функции шума, такой как шум Perlin или Simplex, в качестве строительного блока. Вот как выглядит функция шума.
Каждому местоположению на карте мы присваиваем число от 0,0 до 1,0. На этом изображении 0.0 - черный, а 1.0 - белый.

### Слайд 45
Шум сам по себе - это просто набор цифр. Нам нужно придать ему значение. Первое, о чем мы могли бы подумать, это привести шум в соответствие с высотой (также называемой «картой высот»). Шум может генерироваться на любой частоте.
При перемещении ползунка, можно увидеть, что происходит на разных частотах.

### Слайд 46
Чтобы сделать карту высоты более интересной, я сложила шум на 3х разных частотах в один шум.

// Раньше для таких вещей использовалась функция Перлин noise, но она достаточно громоздкая и сложнее, а симплекс ноиз оптимальнее. //

### Слайд 47
И вот что из этого вышло. Напомню, что в вершинном шейдере смещаются вершины, а во фрагментном раскрашиваются. И значениям из функции шума я присвоила цвета - синий, зеленый и так далее.

### Слайд 48
После этого планета по факту готова. Как бонус я добавила облака. Они также рисуются сферой с чуть большим радиусом, чем планета. Облака используют ту же функцию шума, единственное, что как цвет они используют белый, а шум определяет прозрачность облаков в точке. 

### Слайд 49
Для того чтобы облака с прозрачностью рисовались поверх планеты в javascripte нужно включить альфа блендинг
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

Под капотом фунция блендинга работает таким образом - у нас есть source и destination, source - это облака, а destination - это планета, то есть итоговый цвет мы получаем сложив RGB цвет облаков умноженного на прозрачность облаков с цветом планеты, умноженным на (1 - прозрачность облаков)

blendResult = shaderOutput.rgb * shaderOutput.a + frameBuffer.rgb * (1 - shaderOutput.a);

Ну и бонусои я добавила анимацию вращения облаков вокруг оси y.

### Слайд 50
Для того чтобы сделать 3д модель объёмной, ее необходимо осветить. Для освещения я использую самую простую модель - это модель фонга. Она состоит из 3х компонент - эмбиент, диффуз и отражение (окружающего, рассеянного, отражённого освещения)

* Фоновое освещение (ambient) — имитация света, достигшего заданной точки после отражения от других объектов.
* Рассеянное освещение (diffuse) — свет от источника, рассеянный после попадания в заданную точку. В зависимости от угла, под которым падает свет, освещение становится сильнее или слабее.
* Отраженное освещение (specular) — свет от источника, отраженный после попадания в заданную точку. Отраженный свет виден,если он попадает в камеру.

### Слайд 51
I_p = k_ai_a + k_d\left(\vec{L}.\vec{N}\right)i_d + k_s\left(\vec{R}.\vec{V}\right)^\alpha i_s
Где:
* k_a: материал окружающего освещения (Ambient material)
* k_d: материал рассеянного освещения (Diffuse material)
* k_s: материал отражённого освещения (Specular material)
* a: показатель блеска
* i_a: окружающее освещение
* i_d: рассеянное освещение
* i_s: отражённое освещение
* N: нормаль к поверхности
* L: вектор света
* R: отражение отрицательного значения вектора света
* V: вектор, направленный к зрителю

### Слайд 53
Сглаживание
После того, как планета готова, мы можем заменить некоторые артифакты на границе геометрии, это так называемый алязинг, он вызван тем, что итоговое изображение состоит из пикселей, размер которых виден глазом, и при отрисовке треугольников растеризатор генерирует зубчатый паттерн. 

### Слайд 54
Чтобы решить эту проблему я использовала довольно распространенный алгоритм сглаживания FXAA - fast approximate anti-aliasing. В двух словах - он берет итоговое изображение и проходит попиксельно по нему и пытается понять находимся ли мы на границе геометрии или нет, и если мы на границе, то мы используем не один сэмпл, а несколько, мы их усредняем и получаем более сглаженные края. 
Большинство вычислений в шейдере FXAA будут полагаться на яркость пикселей, считанных из текстуры, выраженных в виде уровней серого в диапазоне от 0,0 до 1,0. Для этого будет использоваться яркость, определяемая по формуле
L = 0,299 * R + 0,587 * G + 0,114 * B - Это взвешенная сумма красного, зеленого и синего компонентов, которая учитывает чувствительность наших глаз к каждому диапазону длин волн.
Определение границ происходит таким образом, что мы RGB-цвет пикселя и цвет его соседей переводим по этой формуле  в яркость, и сравниваем разницу значений по горизонтали и по вертикали.

### Слайд 31-32
Выводы
Заниматься WebGL довольно интересно.
Я писала на чистом WebGL, но есть библиотеки, которые сильно упрощают задачу, вроде three.js, но для этой конкретной задачи эта библиотека слишком громоздкая. 

Литература

==================================================================

### Дополнительно:

Код для программируемых этапов - вершинного и фрагментного буферов пишется на языке GLSL - это императивный процедурный строготипизированный язык с Си-подобным синтаксисом. Он имеет ряд встроенных функций для различных математических операций. И интересная особенность - у него встроен компонент-свизлинг на векторных типах (Swizzle GLSL)- это значит, что переменная состоит из n-количества компонент и есть возможность обратиться к каждой компоненте переменной.
	vec2 someVec;
	vec4 otherVec = someVec.xyxx;
	vec3 thirdVec = otherVec.zyy;

Чтобы выполнить что-то на GPU нам необходимо иметь скомпилированную программу. Это слинкованные вместе скомпилированные вершинный и фрагментый шейдеры. Линковать их необходимо для того, чтобы выходные параметры вершинного шейдера соответствовали входным параметрам фрагментарного шейдера. 
Имея скомпилированную программу, мы можем вызвать команду отрисовки - в WebGL это или DrawElements или DrawArrays. DrawElements использует index- буффер, а DrawArrays не использует index-буффер и считает, что в вершинном буффере каждые три вершины образуют треугольник (то есть вершины могут повторяться), тогда как при использовании index-буффера мы можем ссылаться на одну и ту же вершину по индексу. Поэтому для улучшения производительности чаще используется DrawElements.
Для того, чтобы что-то отобразить необходимо забиндить вершинный буффер, а в случае DrawElements и индексный буфер тоже.
Вершинный буфер - это массив, в котором хранится информация о вершинах, например, позиция вершины (координаты), ее цвет, текстурные координаты, нормаль, тангенс и прочее. Данные из буфера доступны в вершинном шейдере через атрибуты.
Также в шейдерную программу можно передавать константы через uniform переменные - это глобальные переменные, которые устанавливаются перед выполнением программы шейдера. Также у нас есть Varying-переменные позволяют передавать данные из вершинного шейдера фрагментному шейдеру, они интерполируются. 
Еще важная особенность, что в шейдера мы можем читать текстуры - это массивы данных, к которым есть доступ в программе шейдера. Чаще всего в текстуру помещается картинка, но текстура - это просто набор данных и вы можете запросто поместить в неё что-то отличное от набора цветов.

Я взяла изображение и тут-то столкнулась с такой проблемой, что WebGL просто блокирует все изображения, которые приходят с других доменов, потому что в изображениях может содержаться какая-то приватная информация. То есть используя WebGL нет возможности прочитать изображение с другого домена, не запросив разрешение через CORS, поэтому при запросе изображения у сервера мы пишем img.crossOrigin = ‘’; так как по-умолчанию при запросе изображения Img.crossOrigin = undefined, что значит что разрешение не запрашивается. 
Я загрузила изображение через img src и накладывала на него различные фильтры (blur, b/w, анимацию и вращение).
С точки зрения WebGL мы рисуем Quad по размеру canvas - он состоит из 2х треугольников. 

Для того, чтобы сказать видеокарте, что нам нужно отрисовать какое-то количество примитивов мы используем функцию gl.drawElements(...) или gl.drawArrays(...)
* gl.bufferData(...)
* gl.drawElements(...)
* gl.drawArrays(...)





