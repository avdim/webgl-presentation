<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>The WebGL Graphics Pipeline</title>
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">
  <link rel="stylesheet" href="plugin/highlight/styles/docco.css">
  <link rel="icon" type="image/png" href="img/WebGL.png">
  <style>

    .reveal .slide-number {
      font-size: 24px;
      font-weight: bold;
    }

    .reveal section img {
      max-height: 400px;
    }

    .reveal pre {
      box-shadow: none;
    }

    .reveal .me {
      margin-top: 42px;
    }

    .reveal ul ul {
      font-size: 0.8em;
    }

    #rasterization {
      height: 300px;
    }

    .code {
      background: #fff;
      color: #1c1e20;
    }

    .code code {
      font-size: 25px;
    }

  </style>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section style="position: relative;">
        <h1>WebGL Planet</h1>
        <figure>
            <img style="border: none;
            background: transparent;
            box-shadow: none;" class="cover" src="img/planet-main.png" alt="Planet">
        </figure>
        <p>Brought to you by <a href="https://github.com/volkova-annie">Volkova Annie</a></p>
      </section>

      <section>
        <h2>Что такое WebGL?</h2>
        <p> — это графическое API, которое позволяет отправлять команды на видеокарту из JavaScript</p>
      </section>

      <section>
        <h2>Khronos Group Members</h2>
        <img class="img-members" src="img/members.jpeg">
        <style>
          section img.img-members {
            max-height: 600px;
            border: none;
            background: transparent;
            box-shadow: none;
          }
        </style>
      </section>

      <section>
        <header class="cpu-gpu-header"><h2>CPU</h2><h3>vs</h3><h2>GPU</h2></header>
        <ul class="cpu-gpu-list">
          <li>Процессор Core i7, 2,7гГц - 4 ядра, видеокарта Radeon Pro 450 - 640 ядер</li>
          <!-- <li>На CPU может параллельно выполняться 4 потока, а на видеокарте 640 потоков</li> -->
          <li>Видеокарта заточена на параллельное выполнение несвязанных между собой задач</li>
          <!-- <li>На CPU только 2 потока на одном ядре, а на видеокарте около 40 потоков на одном ядре.</li> -->
        </ul>
        <img src="img/cpu-gpu.gif" class="cpu-gpu">

        <style>

          
          header.cpu-gpu-header {
            display: flex;
            justify-content: center;
            align-items: baseline;
          }
          header.cpu-gpu-header h3 {
            margin-left: 15px;
            margin-right: 15px;
          }
          ul.cpu-gpu-list {
            margin-top: 0;
          }
          ul.cpu-gpu-list li {
            font-size: 32px;
            margin-bottom: 15px;
            line-height: 1.2;
          }
          section img.cpu-gpu {
            margin-top: 20px;
            border: none;
            background: transparent;
            box-shadow: none;
          }
        </style>
      </section>

      <section>
        <h2>Основные шаги</h2>
        <ul class="steps-list">
          <li>
            Геометрия состояшая из треугольников
          </li>
          <li>Говорим видеокарте, какие преобразования нужно сделать над треугольниками</li>
          <li>И расскрашиваем их</li>
        </ul>
        <img class="steps" src="img/steps.png">

        <style>
          section img.steps {
            margin-top: 80px;
            border: none;
            background: transparent;
            box-shadow: none;
          }
          ul.steps-list li {
            font-size: 32px;
            margin-bottom: 1px;
            line-height: 1.2;
          }
        </style>
      </section>

      <section>
        <h2>Клиент-серверная модель</h2>
        <ul>
          <li>
            JavaScript code - это клиент
          </li>
          <li>
            Видеокарта - это сервер
          </li>
          <li>
            JavaScript code отправляет запросы на видеокарту через интерфес WebGL
            <ul>
              <li>gl.bufferData(...)</li>
              <li>gl.drawElements(...)</li>
            </ul>
          </li>
        </ul>

        <p style="margin-top: 10px;">Вершинный буффер</p>
          <pre style="margin-top: 0;">
            <code class="javascript" style="line-height: 1; padding: 0;">
        const vertices = new Float32Array([
          // vertex 1
         -0.5, -0.5, 0.0,  // position   
          1.0, 0.0, 0.0,   // normal
          0.5, 0.5,        // texCoord 
          ...
          // vertex n
          1.0, 0.5, 0.0,  // position
          0.0, 1.0, 0.0,  // normal
          1.0, 0.5,       // texCoord
       ]);
          </code>
          </pre>
      </section>

      <section>
        <h2>Графический pipeline WebGL</h2>
        <ul class="pipeline-list">
            <li>Input Assembly</li>
            <li>Vertex shader</li>
            <li>Primitive Assembly</li>
            <li>Rasterizer</li>
            <li>Fragment Shader</li>
            <li>Test and Blending</li>
        </ul>
        <img src="img/pipeline.gif" class="pipeline-img all" style="min-height: 400px;">
        <style>
          section ul.pipeline-list {
            display: flex;
            flex-wrap: wrap;
            margin: 30px 10%;
          }
          section ul.pipeline-list li {
            width: 50%;
          }
          section img.pipeline-img {
            background-color: #ffffff;
            border-color: #ffffff;
            min-height: 500px;
          }

        </style>
      </section>

      <section>
        <h2>Vertex shader</h2>
        <img src="img/pipeline-step2.gif" alt="" class="pipeline-img">
      </section>

      <section>
          <h2>Primitive Assembly</h2>
          <img src="img/pipeline-step3.gif" alt="" class="pipeline-img">
        </section>

      <section>
          <h2>Rasterizer</h2>
          <img src="img/pipeline-step4.gif" alt="" class="pipeline-img">
        </section>

      <section>
          <h2>Fragment Shader</h2>
          <img src="img/pipeline-step5.gif" alt="" class="pipeline-img">
        </section>

      <section>
          <h2>Test and Blending + Output Buffer</h2>
          <img src="img/pipeline-step6.gif" alt="" class="pipeline-img">
        </section>

      <section>
        <h2>Вершинный шейдер</h2>
           <!-- - <h3>(программируемый этап)</h3> -->
        <div style="display: flex;">
          <ul>
            <li>Данные, которые описывают вершину</li>
            <li>На выходе вершинный шейдер возвращает позицию вершины в gl_Position</li>
          </ul>
          <!-- <img id="" src="img/ndc.png"> -->
        </div>
        <pre>
            <code class="c">
    // attribute means it comes from the geometry array we created
    attribute vec3 a_position;
    attribute vec3 a_normal;
    // uniforms - constants
    uniform mat4 u_worldTransform;
    uniform mat4 u_viewProjection;
    // output to fragment shader
    varying vec3 v_normal;

    void main() {
      vec4 worldPos = u_worldTransform * vec4(a_position, 1.0);
      vec4 viewPos = u_viewProjection * worldPos;

      v_normal = mat3(u_worldTransform) * a_normal;
      gl_Position = viewPos;
    }
          </code>
        </pre>
      </section>

      <section>
          <h2>Вершинный шейдер</h2>
          <img src="img/ndc.png" width="475" style="max-height: 500px">

      </section>

      <section>
        <h2>Растеризация
           <!-- - <h3>(непрограммируемый этап)</h3> -->
          </h2>
        <ul>
          <li>Видеокарта определяет, какие пиксели в итоговом Frame buffer перекрываются рисуемым примитивом</li>
          <li>Интерполяция данных вершин внутри треугольника</li>
          <!-- <li>Interpolates vertex data to pixels along triangle surface</li> -->
        </ul>
        <img src="img/rasterization.png">
      </section>

      <section>
        <h2>Фрагментный шейдер
           <!-- - <h3>(программируемый этап)</h3> -->
        </h2>
        <ul>
          <li>
            Для каждого фрагмента, полученного из Rasterizer мы выполняем один фрагментый shader
          </li>
          <li>
            На выходе фрагментый шейдер нам дает цвет итогового фрагмента
          </li>
              <!-- Set gl_FragColor to tell WebGL the final color of a pixel -->
        </ul>
        <pre>
            <code class="c">
    // uniforms
    uniform vec3 u_lightDir;
    uniform vec3 u_lightColor;
    //input from vertex shader
    varying vec3 v_normal;
    
    void main() {
      float NoL = max(dot(v_normal, -u_lightDir), 0.0);
      gl_FragColor = vec4(NoL * u_lightColor, 1.0);
    }
          </code>
        </pre>
      </section>

      <section>
        <h2>Let's get started!</h2>
      </section>

      <section class="section-gif">
        <h2>
            WebGL 2d
        </h2>
        <img src="videos/2d.gif" class="image-gif" alt="2d-gif">
        <style>
          /* section img.flat-view {
            border: none;
            max-height: 600px;
          } */
        </style>
      </section>

      <section class="section-planer-view">
        <h2>WebGL 3D</h2>
        <img class="planet-view" src="img/planet.png" alt="3d-view">
        <style>
          /* section img.section-planer-view {
            border: none;
            max-height: 600px;
          } */
          section.section-planer-view.present {
            top: -56% !important;
            left: -500px;
            width: auto;
          }

          section img.planet-view {
            border: none;
            max-height: 660px;
            min-width: 1000px;
            margin-bottom: auto;
          } 
        </style>
      </section>

      <section>
        <h2>Проекция</h2>
        <ul>
          <li>Ортогональная - линии проецирования переносятся перпендикулярно плоскости проекции</li>
          <li>Перспективная - луч проекции идет от проецируемой точки в позицию камеры</li>
        </ul>
        <img class="projection" src="img/projection.png" alt="projection">

        <style>
          section img.projection {
            background-color: #ffffff;
          }
        </style>
      </section>

      <section>
        <h2>Four Ways to Create a Mesh for a Sphere</h2>
        <img src="img/spheres.png" alt="spheres" style="max-height: 500px">
        <!-- <a href="https://medium.com/game-dev-daily/four-ways-to-create-a-mesh-for-a-sphere-d7956b825db4" style="display: block;">
          Four Ways to Create a Mesh for a Sphere
        </a> -->
      </section>

      <section>
        <h2>Noise</h2>
        <img src="img/noise.jpg" alt="noise">
        <pre>
          <code>
              elevation[y][x] =    1 * noise(1 * nx, 1 * ny);
              +  0.5 * noise(2 * nx, 2 * ny);
              + 0.25 * noise(4 * nx, 2 * ny);
          </code>
        </pre>
      </section>

      <section>
          <h2>Noise</h2>
          <img src="img/noise-3d.png" alt="noise" style="max-height: 700px;width: 800px;">
      </section>

      <section class="section-gif">
        <h2>
          Planet
        </h2>
        <img src="videos/planet.gif" class="image-gif" alt="planet-gif">
        <style>
          section.section-gif.present {
            top: -56% !important;
            left: -550px;
            width: auto;
          }

          section img.image-gif {
            border: none;
            max-height: 700px;
            min-width: 1100px;
            margin-bottom: auto;
          } 
        </style>
      </section>

      <section>
        <h2>Освещение по Фонгу</h2>
        <img src="img/phong-sum.png" alt="">
        <div><i style="position: relative">
          I<sub>p</sub> = k<sub>α</sub> i<sub>α</sub> 
          +  k<sub>d</sub>(<span class="with-arrow">L</span>.<span class="with-arrow">N</span>) i<sub>d</sub> 
          + k<sub>s</sub>(<span class="with-arrow">R</span>.<span class="with-arrow">V</span>)<sup>α</sup>        i<sub>s</sub>
        </i>
      </div>

      <style>
        .with-arrow {
          position: relative;
        }
        .with-arrow::before {
          content: '→';
          position: absolute;
          top: -20px;
          left: 20%;
          font-size: 60%;
        }
        .reveal i sup {
          font-size: 60%;
          position: absolute;
          top: -22px;
        }

        .reveal i sub {
          font-size: 60%;
        }

      </style>
       
     </section>

      <section>
          <h2>Освещение</h2>
          <img src="img/light.gif" alt="">
      </section>

      <section>
        <h2>FXAA - fast approximate anti-aliasing</h2>
        <div class="fxaa-wrapper">
          <img class="fxaa-img" src="img/fxaa2.png" alt="fxaa-before">
          <img class="fxaa-img" src="img/fxaa1.png" alt="fxaa-after">
        </div>

        <style>
        section .fxaa-wrapper {
          display: flex;
          align-items: center;
          justify-content: space-between;
          margin-top: 100px;
        }
        section .fxaa-wrapper img.fxaa-img {
          height: auto;
          width: 49%;
          border: none;
        }
        </style>
      </section>

      <section>
        <h2>Сглаживание</h2>
        <div>
          <img src="img/fxaa-before.jpg" alt="fxaa-before">
          <img src="img/fxaa-after.jpg" alt="fxaa-after">
        </div>
      </section>

      <section>
        <h2>Выводы</h2>
      </section>

      <section>
        <h2>Литература</h2>
        <ul>
          <li>
            <a href="https://webglfundamentals.org/">
              WebGL Fundamentals
            </a>
          </li>
          <li>
            <a href="https://www.tutorialspoint.com/webgl/webgl_graphics_pipeline.htm">
              WebGL - Graphics Pipeline
            </a>
          </li>
          <li>
            <a href="https://tproger.ru/articles/cpu-and-gpu/">
              В чем разница между CPU и GPU?
            </a>
          </li>
          <li>
            <a href="https://medium.com/game-dev-daily/four-ways-to-create-a-mesh-for-a-sphere-d7956b825db4">
              Four Ways to Create a Mesh for a Sphere
            </a>
          </li>
          <li>
            <a href="https://www.redblobgames.com/maps/terrain-from-noise/">
              Making maps with noise functions
            </a>
          </li>
          <li>
            <a href="http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html">
              Implementing FXAA
            </a>
          </li>
          <li>
            <a href="https://habr.com/en/post/446682/">
              Ускоряем WebGL/Three.js с помощью OffscreenCanvas и веб-воркеров
            </a>
          </li>
        </ul>
      </section>

      <section>
        <h2>Спасибо :)</h2>
      </section>

      <!-- <section>
        <h2>Even the longest journey begins with a single step...</h2>
        <img src="img/tri.jpeg">
      </section>

      <section>
        <h2>The basic idea...</h2>
        <ul>
          <li>
            If we can draw triangles and color them, we can build Assassin's Creed
            <ul>
              <li>(At least the graphical part)</li>
            </ul>
          </li>
        </ul>
      </section> -->

      <!-- <section>
        <h2>Basic steps</h2>
        <ul>
          <li>Describe surface geometry in triangles</li>
          <li>Tell the GPU how it should manipulate the triangles and color them</li>
          <li>Draw</li>
        </ul>
      </section> -->

      <!-- <section>
        <h2>Client/Server Model</h2>
        <ul>
          <li>JavaScript code is the client</li>
          <li>GPU is the server</li>
          <li>
            JavaScript code sends commands and data to the GPU via WebGL
            <ul>
              <li>gl.bufferData(...)</li>
              <li>gl.drawArrays(...)</li>
            </ul>
          </li>
        </ul>
      </section> -->

      <!-- <section>
        <h2>State Machine</h2>
        <ul>
          <li>
            WebGL commands set up state on the GPU
            <ul>
              E.g. Geometry, colors, etc.
            </ul>
          </li>
          <li>That state is used in the next draw command.</li>
        </ul>
      </section> -->

      <!-- <section>
        <h2>State Machine</h2>
        <img src="img/client-server.png">
      </section>

      <section>
        <h2>Describe Geometry</h2>
        <ul><li>Array of vertex data</li></ul>
        <pre>
            <code class="javascript">
    var positions = new Float32Array([
      -0.5, -0.5, 0.0,  // Vertex 1
       0.5, -0.5, 0.0,  // Vertex 2
       0.0,  0.5, 0.0   // Vertex 3
    ]);
          </code>
        </pre>
      </section> -->

      <section>
        <h2>Basic steps on the GPU</h2>
        <ul>
          <li>Move vertices around (vertex shader)</li>
          <li>Map triangles to pixels on the screen (rasterization)</li>
          <li>Color the pixels (fragment shader)</li>
          <li>Display the scene</li>
        </ul>
      </section>

      <section>
        <h2>The process</h2>
        <img src="img/parallel.png">
      </section>

      <section>
        <h2>Pipeline Components</h2>
        <img src="img/pipeline.png">
      </section>

      <section>
        <h2>We control</h2>
        <ul>
          <li>Vertex shader</li>
          <li>Set gl_Position to tell WebGL the final vertex position</li>
        </ul>
        <pre>
          <code class="c">
  // attribute means it comes from the geometry
  // array we created!
  attribute vec4 aPosition;

  void main() {
    gl_Position = aPosition;
  }
        </code>
      </pre>
      </section>

      <section>
        <h2>Normalized Device Coordinates</h2>
        <ul>
          <li>gl_Position is given in normalized device coordinates</li>
        </ul>
        <img id="rasterization" src="img/ndc.png">
      </section>

      <section>
        <h2>We don't control</h2>
        <ul>
          <li>
            Rasterization
            <ul>
              <li>GPU figures out which pixels are covered by each triangle</li>
              <li>Interpolates vertex data to pixels along triangle surface</li>
            </ul>
          </li>
        </ul>
        <!-- Image by Martin Kraus http://en.wikibooks.org/wiki/GLSL_Programming/Rasterization#/media/File:Pixels_covered_by_a_triangle.png -->
        <img src="img/rasterization.png">
      </section>

      <section>
        <h2>We control</h2>
        <ul>
          <li>Fragment shader</li>
          <li>Set gl_FragColor to tell WebGL the final color of a pixel</li>
        </ul>
        <pre>
          <code class="c">
  void main() {
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  }
        </code>
      </pre>
      </section>

      <section>
        <h2>Let's get started!</h2>
      </section>

      <section>
        <h2>What we did</h2>
        <ul>
          <li>Shaders</li>
          <li>Programs</li>
          <li>Attributes</li>
          <li>Array buffers</li>
          <li>Varyings</li>
          <li>Uniforms</li>
        </ul>
      </section>

      <section>
        <h2>Shaders</h2>
        <ul>
          <li>Vertex shader moves each vertex to its final NDC position</li>
          <li>Fragment shader colors a pixel covered by a triangle</li>
        </ul>
      </section>

      <section>
        <h2>Programs</h2>
        <ul>
          <li>Combination of a vertex and a fragment shader</li>
        </ul>
      </section>

      <section>
        <h2>Attributes</h2>
        <ul>
          <li>Per vertex data passed to vertex shader</li>
          <li>Includes positions, colors, normals, texture coordinates, etc.</li>
        </ul>
      </section>

      <section>
        <h2>Array buffers</h2>
        <ul>
          <li>Storage location on GPU for vertex data</li>
          <li>Data has to be passed from the program into an array buffer</li>
          <li>Array buffer has to be bound to an attribute in the vertex shader</li>
          <li>Pointer must be enabled to tell GPU how to traverse the array</li>
        </ul>
      </section>

      <section>
        <h2>Varyings</h2>
        <ul>
          <li>Data passed from vertex to fragment shader</li>
          <li>Output from vertex shader as per-vertex data</li>
          <li>Interpolated across triangle surface in rasterization step</li>
          <li>Interpolated values passed to fragment shader as per-pixel data</li>
        </ul>
      </section>

      <section>
        <h2>Uniforms</h2>
        <ul>
          <li>Data passed from program to both vertex shader and fragment shader</li>
          <li>Remains constant for all vertices/pixels of a given object</li>
          <li>E.g. light position, camera position, time</li>
        </ul>
      </section>

      <section>
        <h2>That's pretty much it!</h2>
        <ul>
          <li>That pretty much all the API you need to know to draw with WebGL</li>
          <li>
            A couple of important ommissions:
            <ul>
              <li>Textures</li>
              <li>Frame buffers</li>
            </ul>
          </li>
        </ul>
      </section>

      <section>
        <h1>Thanks!</h1>
        <div class="credits">
          <ul>
            <li><a href="mailto:tarek@biodigital.com">tarek@biodigital.com</a></li>
            <li><a target="_blank" href="https://twitter.com/thsherif">@thsherif</a></li>
            <li><a target="_blank" href="https://www.biodigital.com">www.biodigital.com</a></li>
          </ul>
        </div>
      </section>

    </div>
  </div>
  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.min.js"></script>
  <script src="js/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      history: true,
      slideNumber: true,
      controls: false
    });

    Reveal.addEventListener("slidechanged", function(event) {
      window.onresize();
    });

    hljs.initHighlightingOnLoad();

  </script>
</body>
</html>
